{
    "Initialize cpp": {
        "prefix": "!!!",
        "body": ["#include <${1:bits/stdc++.h}>", "", "using namespace std;", "", "int main() {", "    $0", "    return 0;", "}"]
    },

    "Initialize cpp with array": {
        "prefix": "!!",
        "body": ["#include <${1:bits/stdc++.h}>", "", "using namespace std;", "", "int T[${2:/* length */}];", "", "int main() {", "    $0", "    return 0;", "}"]
    },

    "Declare function main": {
        "prefix": "!main",
        "body": ["int main () {", "    $0", "    return 0;", "}"]
    },

    "file header": {
        "prefix": "!fileheader",
        "body": [
            "/**",
            "**********************************************************************************************************************************************************************************************************************************",
            "* @file:\t$TM_FILENAME",
            "* @author:\t$1",
            "* @date:\t$CURRENT_YEAR.$CURRENT_MONTH.$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND $CURRENT_DAY_NAME",
            "* @brief:\t$2",
            "**********************************************************************************************************************************************************************************************************************************",
            "**/"
        ],
        "description": "Initialize file header"
    },

    "include": {
        "prefix": "#inc",
        "body": ["#include <${1:bits/stdc++.h}>$0"],
        "description": "snippet for #include"
    },

    "namespace": {
        "prefix": "!using",
        "body": ["using namespace ${1:std};$0"],
        "description": "Add namespace"
    },

    "long long": {
        "prefix": "!LL",
        "body": ["using LL = long long;"],
        "description": "Create long long alias"
    },

    "tab": {
        "prefix": "!tab",
        "body": ["${1:int} A[${2:1000000}];"],
        "description": "Create array"
    },

    "array": {
        "prefix": "!arr",
        "body": ["array<${1:int}, ${2:2}>"],
        "description": "Create an array"
    },

    "vector": {
        "prefix": "!vec",
        "body": ["vector<${1:int}> ${2:vec};"],
        "description": "Create vector"
    },

    "set": {
        "prefix": "!set",
        "body": ["set<${1:int}> S;"],
        "description": "Create set"
    },

    "unordered set": {
        "prefix": "!uset",
        "body": ["unordered_set<${1:int}> S;"],
        "description": "Creates unordered set"
    },

    "multiset": {
        "prefix": "!mset",
        "body": ["multiset<${1:int}> S;"],
        "description": "Creates multiset"
    },

    "unordered multiset": {
        "prefix": "!umset",
        "body": ["unordered_multiset<${1:int}> S;"],
        "description": "Creates unordered multiset"
    },

    "map": {
        "prefix": "!map",
        "body": ["map<${1:int}, ${2:int}> M;"],
        "description": "Create map"
    },

    "unordered map": {
        "prefix": "!umap",
        "body": ["unordered_map<${1:int}, ${2:int}> M;"],
        "description": "Create unordered map"
    },

    "stack": {
        "prefix": "!stack",
        "body": ["stack<${1:int}> Q;"],
        "description": "Create a stack"
    },

    "queue": {
        "prefix": "!queue",
        "body": ["queue<${1:int}> Q;"],
        "description": "Create queue"
    },

    "dequeue": {
        "prefix": "!dequeue",
        "body": ["dequeue<${1:int}> Q;"],
        "description": "Create dequeue"
    },

    "priority queue": {
        "prefix": "!pqueue",
        "body": ["priority_queue<${1:int}> Q;"],
        "description": "Create priority queue"
    },

    "pair": {
        "prefix": "!pair",
        "body": ["pair<${1:int}, ${2:int}>"],
        "description": "Create a pair"
    },

    "tuple": {
        "prefix": "!tuple",
        "body": ["tuple<${1:int}, ${2:int}, ${3:int}>"],
        "description": "Create a tuple"
    },

    "get_tuple": {
        "prefix": "!get_tuple",
        "body": ["get<${1:index}>(${2:var})"],
        "description": "Create a tuple"
    },

    "greater": {
        "prefix": "!greater",
        "body": ["greater<${1:int}>"],
        "description": "Create a greater comparator"
    },

    "Normal for loop": {
        "prefix": "!for",
        "body": ["for (int ${1:i} = ${2:0}; ${1:i} < ${3:n}; ${1:i}++) {", "    $4", "}$0"],
        "description": "Simple for loop"
    },

    "Reverse for loop": {
        "prefix": "!forr",
        "body": ["for (int i = ${1:n - 1}; i >= 0; i--) {", "    $2", "}$0"],
        "description": "Reverse for loop"
    },

    "Colon for loop": {
        "prefix": "!fora",
        "body": ["for (auto i : ${1:vec}) {", "    $2", "}$0"],
        "description": "Colon for loop"
    },

    "endline": {
        "prefix": "!n",
        "body": "<< '\\n';",
        "description": "Adds endline to cout"
    },

    "Make ur code faster": {
        "prefix": "!fast",
        "body": ["ios_base::sync_with_stdio(false);", "cin.tie(0);", "cout.tie(0);"]
    },

    "swap": {
        "prefix": "!swap",
        "body": ["swap(${1:a}, ${2:b});"],
        "description": "Create unordered set"
    },

    "next permutation": {
        "prefix": "!nperm",
        "body": ["next_permutation(${1:vec}.begin(), ${1:vec}.end())"],
        "description": "Create priority queue"
    },

    "srand": {
        "prefix": "!rand",
        "body": ["srand(${1:seed})"],
        "description": "Generate random number from seed"
    },

    "lower_bound": {
        "prefix": "!lower_bound",
        "body": ["lower_bound(${1}.begin(), ${1}.end(), ${2:number})"],
        "description": "Returns an iterator pointing to the first element in the range first,last which does not compare less than val."
    },

    "upper_bound": {
        "prefix": "!upper_bound",
        "body": ["upper_bound(${1}.begin(), ${1}.end(), ${2:number})"],
        "description": "Returns an iterator pointing to the first element in the range first,last which compares greater than val."
    },

    "assert": {
        "prefix": "!assert",
        "body": ["assert((${1:/* Condition to validate */}))"],
        "description": "Checks if condition is true"
    },

    "cerr": {
        "prefix": "!cerr",
        "body": ["cerr >> $0;"],
        "description": "Helpful for printing debug information"
    },

    "gcd": {
        "prefix": ["!gcd", "!nwd"],
        "body": ["${1:int} GCD(${1:int} a, ${1:int} b) {", "  if (b == 0) return a;", "  return GCD(b, a % b);", "}"],
        "description": "Greatest common divisor function"
    },

    "gcf": {
        "prefix": ["!gcf", "!nww"],
        "body": ["int GCF(int a, int b) { return a / GCD(a, b) * b; }"],
        "description": "Greatest common factor function"
    },

    "fastPowMod": {
        "prefix": "!fastPowMod",
        "body": [
            "long long myPow(int a, int exponent, int m) {",
            "    if (!exponent) return 1;",
            "    long long tmp = myPow(a, exponent / 2, m);",
            "    if (exponent & 1) return (((tmp * tmp) % m) * a) % m;",
            "    return (tmp * tmp) % m;",
            "}"
        ],
        "description": "Quickly calculate a^b mod c"
    },

    "newton": {
        "prefix": "!newton",
        "body": [
            "template <typename FactorialType, int size>",
            "class Newton {",
            "    FactorialType F[size];",
            "    FactorialType modulo;",
            "",
            "    FactorialType fast_mod_power(FactorialType a, FactorialType exponent) {",
            "        if (!exponent) return 1;",
            "        if (exponent & 1) return (a * fast_mod_power(a, exponent - 1)) % modulo;",
            "        return fast_mod_power((a * a) % modulo, exponent / 2) % modulo;",
            "    }",
            "",
            "   public:",
            "    Newton(int modulo_value) {",
            "        modulo = modulo_value;",
            "        F[0] = 1;",
            "        for (FactorialType i = 1; i < size; ++i) {",
            "            F[i] = (F[i - 1] * i) % modulo;",
            "        }",
            "    }",
            "    FactorialType get_reverse_factor(FactorialType x) { return fast_mod_power(F[x], modulo - 2); }",
            "    FactorialType get_factor(FactorialType x) { return F[x]; }",
            "    FactorialType n_choose_k(FactorialType n, FactorialType k) { return ((((F[n] * get_reverse_factor(k)) % modulo)) * get_reverse_factor(n - k)) % modulo; }",
            "};"
        ],
        "description": "Calculate newton symbol and get factors"
    },

    "two pow ceil": {
        "prefix": "!two_ceil",
        "body": [
            "unsigned int two_ceil(unsigned int a) {",
            "    a--;",
            "    a |= a >> 1;",
            "    a |= a >> 2;",
            "    a |= a >> 4;",
            "    a |= a >> 8;",
            "    a |= a >> 16;",
            "    a++;",
            "    return a;",
            "}"
        ],
        "description": "Get the next closest power of 2 to the given number"
    },

    "log": {
        "prefix": "!log",
        "body": [
            "long long Pow(long long y, long long x) {",
            "    if (x == 0) return 1;",
            "    return y * Pow(y, x - 1);",
            "}",
            "",
            "long long Log(long long base, long long argument) {",
            "    long long a = -1LL, b = argument, c = 0LL;",
            "    while (a + 1 != b) {",
            "        c = (a + b) / 2;",
            "        if (Pow(base, c) <= argument) {",
            "            a = c;",
            "        } else {",
            "            b = c;",
            "        }",
            "    }",
            "    return a;",
            "}"
        ],
        "description": "Get the next closest power of 2 to the given number"
    },

    "pow": {
        "prefix": "!pow",
        "body": ["long long Pow(int y, int x) {", "    if (x == 0) return 1;", "    return y * Pow(y, x - 1);", "}"],
        "description": "Quickly calculate a^b mod c"
    },

    "find": {
        "prefix": "!find",
        "body": ["int Find(int a) {", "if (${1:array}[a] != a) ${1:array}[a] = Find(${1:array}[a]);", "return ${1:array}[a];", "}"],
        "description": "Find function"
    },

    "binary search": {
        "prefix": "!binsrc",
        "body": [
            "int binSrc(int a, int b) {",
            "  while (a + 1 != b) {",
            "    int c = (a + b) / 2;",
            "    if (${1:/* Your condition goes here */}) {",
            "        a = c;",
            "    } else {",
            "        b = c;",
            "    }",
            "  }",
            "  return a;",
            "}"
        ],
        "description": "Binary search function"
    },

    "breadth-first search": {
        "prefix": "!bfs",
        "body": [
            "void BFS(int s) {",
            "  queue<int> Q;",
            "  vector<int> visited;",
            "  Q.push(s);",
            "  visited[s] = true;",
            "  while (!Q.empty()) {",
            "    int x = Q.front();",
            "    Q.pop();",
            "    for (auto i : vec[x]) {",
            "      if (!visited[i]) {",
            "        Q.push(i);",
            "        visited[i] = true;",
            "      }",
            "    }",
            "  }",
            "}"
        ],
        "description": "Breadth-first search algorithm"
    },

    "depth-first search": {
        "prefix": "!dfs",
        "body": ["void DFS(int x) {", "  if (visited[x]) return;", "  visited[x] = true;", "  for (auto i : graph[x]) {", "    DFS(i);", "  }", "}"],
        "description": "Depth-first search algorithm"
    },

    "minimum spanning tree": {
        "prefix": "!mst",
        "body": ["void"],
        "description": "Minimum spanning tree algorithm"
    },

    "dijkstra": {
        "prefix": "!dijkstra",
        "body": [
            "void DIJ(int start) {",
            "  priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> Q;",
            "  Q.push({0, start});",
            "  while (!Q.empty()) {",
            "    int distance = Q.top().first, vertex_number = Q.top().second;",
            "    Q.pop();",
            "    if (visited[vertex_number]) continue;",
            "    visited[vertex_number] = true;",
            "    distances[vertex_number] = distance;",
            "    for (const auto vertex : graph[vertex_number]) {",
            "      if (!visited[vertex.first]) {",
            "        Q.push({vertex.second + distance, vertex.first});",
            "      }",
            "    }",
            "  }",
            "}"
        ],
        "description": "Dijkstra's algorithm"
    },

    "interval set": {
        "prefix": "!IntervalSet",
        "body": [
            "template <class T = int>",
            "struct IntervalSet {",
            "    std::set<pair<T, T>> S;",
            "",
            "    IntervalSet() {",
            "        S.insert({",
            "            std::numeric_limits<T>::max(),",
            "            std::numeric_limits<T>::max(),",
            "        });",
            "        S.insert({",
            "            std::numeric_limits<T>::min(),",
            "            std::numeric_limits<T>::min(),",
            "        });",
            "    }",
            "",
            "    void insert(int a, int b) {",
            "        auto it = std::prev(S.upper_bound({b + 1, std::numeric_limits<T>::max()}));",
            "        while (it->second + 1 >= a) {",
            "            a = std::min(it->first, a);",
            "            b = std::max(it->second, b);",
            "            it = std::prev(it);",
            "            S.erase(std::next(it));",
            "        }",
            "        S.insert({a, b});",
            "    }",
            "",
            "    void erase(int a, int b) {",
            "        auto it = std::prev(S.upper_bound({b, std::numeric_limits<T>::max()}));",
            "        while (it->second >= a) {",
            "            if (b + 1 <= it->second) S.insert({b + 1, it->second});",
            "            if (it->first <= a - 1) S.insert({it->first, a - 1});",
            "            it = std::prev(it);",
            "            S.erase(next(it));",
            "        }",
            "    }",
            "",
            "    void forInRange(int a, int b, std::function<void(T, T)> lmb) {",
            "        auto it = std::prev(S.upper_bound({b, std::numeric_limits<T>::max()}));",
            "        while (it->second >= a) {",
            "            lmb(std::max(a, it->first), std::min(b, it->second));",
            "            it = std::prev(it);",
            "        }",
            "    }",
            "",
            "    void forNotInRange(int a, int b, std::function<void(T, T)> lmb) {",
            "        auto it = S.upper_bound({b, std::numeric_limits<T>::max()});",
            "        while (it->second >= a) {",
            "            if (std::max(a, std::prev(it)->second + 1) <= std::min(b, it->first - 1)) {",
            "                lmb(std::max(a, std::prev(it)->second + 1), std::min(b, it->first - 1));",
            "            }",
            "            it = std::prev(it);",
            "        }",
            "    }",
            "};"
        ],
        "description": "Structure for saving intervals and erasing them."
    },

    "interval tree - point, range": {
        "prefix": "!IntervalTree",
        "body": [
            "template <class NodeType = int, class ReducerType = long long>",
            "struct IntervalTree {",
            "    std::vector<NodeType> nodes;",
            "    long long BASE;",
            "    unsigned int next_pos = 0;",
            "    NodeType defaultValue;",
            "    ReducerType startingValue;",
            "    virtual ReducerType getValueOperation(NodeType& newValue, ReducerType& currentValue) { return newValue + currentValue; }",
            "    virtual ReducerType setValueOperation(NodeType& newValue, ReducerType& oldValue) { return newValue; }",
            "",
            "    unsigned int two_ceil(unsigned int a) {",
            "        --a;",
            "        a |= a >> 1;",
            "        a |= a >> 2;",
            "        a |= a >> 4;",
            "        a |= a >> 8;",
            "        a |= a >> 16;",
            "        ++a;",
            "        return a;",
            "    }",
            "",
            "    IntervalTree(unsigned int size, NodeType defaultValue = 0, ReducerType stVal = 0) {",
            "        BASE = two_ceil(size);",
            "        nodes.resize(2 * BASE + 2, defaultValue);",
            "        startingValue = stVal;",
            "    }",
            "",
            "    void insert(NodeType value) { nodes[BASE + next_pos++] = value; }",
            "",
            "    ReducerType query(int start, int end) {",
            "        ReducerType result = startingValue;",
            "        start += BASE - 2;",
            "        end += BASE;",
            "        for (; (start >> 1) != (end >> 1); (start >>= 1), (end >>= 1)) {",
            "            if ((start & 1) == 0) {",
            "                result = getValueOperation(nodes[start + 1], result);",
            "            }",
            "            if ((end & 1) == 1) {",
            "                result = getValueOperation(nodes[end - 1], result);",
            "            }",
            "        }",
            "        return result;",
            "    }",
            "",
            "    void update(int position, NodeType value) {",
            "        position = position + BASE - 1;",
            "        nodes[position] = setValueOperation(value, nodes[position]);",
            "        for (int i = (position >> 1); 0 < i; (i >>= 1)) {",
            "            nodes[i] = getValueOperation(nodes[i * 2], nodes[i * 2 + 1]);",
            "        }",
            "    }",
            "",
            "    void refreshValues() {",
            "        for (int i = BASE / 2; 0 < i; i /= 2) {",
            "            for (int j = i; j < i * 2; j++) {",
            "                nodes[j] = getValueOperation(nodes[j * 2], nodes[j * 2 + 1]);",
            "            }",
            "        }",
            "    }",
            "};"
        ],
        "description": "interval tree - point, range"
    },

    "interval tree - range, point": {
        "prefix": "!RevIntervalTree",
        "body": [
            "template <class NodeType = int, class ReducerType = long long>",
            "struct RevIntervalTree {",
            "    std::vector<NodeType> nodes;",
            "    long long BASE;",
            "    unsigned int next_pos = 0;",
            "    NodeType defaultValue;",
            "    ReducerType startingValue;",
            "    virtual ReducerType getValueOperation(NodeType& newValue, ReducerType& currentValue) {",
            "        return newValue + currentValue;",
            "    }",
            "    virtual ReducerType setValueOperation(NodeType& newValue, NodeType& oldValue) {",
            "        return newValue + oldValue;",
            "    }",
            "",
            "    unsigned int two_ceil(unsigned int a) {",
            "        --a;",
            "        a |= a >> 1;",
            "        a |= a >> 2;",
            "        a |= a >> 4;",
            "        a |= a >> 8;",
            "        a |= a >> 16;",
            "        ++a;",
            "        return a;",
            "    }",
            "",
            "    RevIntervalTree(unsigned int size, NodeType defaultValue = 0, ReducerType stVal = 0) {",
            "        BASE = two_ceil(size);",
            "        nodes.resize(2 * BASE + 2, defaultValue);",
            "        startingValue = stVal;",
            "    }",
            "",
            "    void insert(NodeType value) { nodes[BASE + next_pos++] = value; }",
            "",
            "    void update(int start, int end, NodeType value) {",
            "        start += BASE - 2;",
            "        end += BASE;",
            "        for (; (start >> 1) != (end >> 1); (start >>= 1), (end >>= 1)) {",
            "            if ((start & 1) == 0) {",
            "                nodes[start + 1] = setValueOperation(value, nodes[start + 1]);",
            "            }",
            "            if ((end & 1) == 1) {",
            "                nodes[end - 1] = setValueOperation(value, nodes[end - 1]);",
            "            }",
            "        }",
            "    }",
            "",
            "    ReducerType query(int position) {",
            "        ReducerType result = startingValue;",
            "        position = position + BASE - 1;",
            "        result = getValueOperation(nodes[position], result);",
            "        for (int i = (position >> 1); 0 < i; (i >>= 1)) {",
            "            result = getValueOperation(nodes[i], result);",
            "        }",
            "        return result;",
            "    }",
            "};"
        ],
        "description": "interval tree - range, point"
    }
}
